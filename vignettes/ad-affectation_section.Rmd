---
title: "ad-affectation_section"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ad-affectation_section}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message = FALSE}
library(evavelo)
library(dplyr)
library(banR)
```
## Intro

Dans le chapitre 3.1.30:

Dans le cadre des extrapolations à conduire, il sera nécessaire de disposer d’une matrice des origines et destinations des itinérants. Celle-ci permettra de recomposer la répartition spatiale de la fréquentation itinérante sur l’itinéraire ou le réseau. La construction de cette matrice sera faite à partir des numéros des sections correspondant (id) aux communes de départ sur l’itinéraire [iti_depart_iti_valide] et d’arrivée sur l’itinéraire [iti_arrivee_iti_valide] déclarées par les répondants à la question 26. Pour réaliser cette matrice, il faut tout d’abord créer les champs [id_section_origine] et [id_section_dest]. Ensuite, l’affectation des « id » de section est faite en utilisant une fonction recherche entre la base de réponse et la table des communes de l’itinéraire [table_communes].

Il faut donc que je remplisse les champs **id_section_origine** et **id_section_dest** qui sont dans enquetes_post_traitement

```{r}
xlsx_path <- here::here("inst", "example-data", "02_simplified.xlsx")
enquete <- read_enquete(xlsx_path)

table_com <- openxlsx::read.xlsx(xlsx_path, sheet = "table_communes", startRow = 2)
```


```{r}
enquete %>% 
  select(id_quest, iti_depart_itineraire) %>% 
  count(iti_depart_itineraire)

```

## Detection de communes (table_communes)

Il va falloir faire de la reconnaissance de site.
J'utilise le package banR que j'ai légèrement modifié pour filtrer les communes.
Si jamais ma PR (https://github.com/joelgombin/banR/pull/32) n'est pas incorporée au package, il faudra que je redeveloppe la fonctionalté ici.

La fonction geocode_tbl() est beaucoup plus rapide que la fonction geocode. Je peux en plus préciser un code Insee.
Je vais utiliser cette fonction pour vérifier la table des communes. 




```{r}
## example of BanR use:
banR::geocode("perros", limit = 1, type = "municipality")


villes <- c("perros", "evron", "trezeny", "st brieuc", "zzz")
table_communes <- openxlsx::read.xlsx(xlsx_path, sheet = "table_communes", startRow = 2)
villes_itineraire <- table_communes$nom_commune

## Modify input to create an error
table_communes[1,"nom_commune"]<- "TREZENY"


## function that uses city names and COG codes to find position
evavelo::geocode_table_communes(table_communes) %>% 
  select(COG, nom_commune, latitude, longitude) %>% 
  head(20)



```

## Detection de commune (enquete)
*3.1.19*	Communes d’hébergement, de départ et d’arrivée, de résidence et code postal

Il est nécessaire d’homogénéiser la saisie des noms et de vérifier la concordance entre le nom de la commune et le code postal. Pour les communes d’hébergement [ville_heb], de départ sur l’itinéraire [iti_depart_itineraire] et d’arrivée sur l’itinéraire [iti_arrivee_itineraire], il est nécessaire de vérifier l’appartenance de ces communes à l’itinéraire ou au réseau évalué.


Finalement, j'ai plusieurs villes à étudier:

* ville_heb
* ville_res (associé à cp_res)
* iti_depart_itineraire
* iti_arrivee itineraire


```{r}

enquete <- read_enquete(xlsx_path) %>% 
  select(ville_heb, ville_res, iti_depart_itineraire, iti_arrivee_itineraire, cp_res, pays_res)


## Lets' work with ville_res first

enquete_post <- geocode_cities_cp(enquete, city_col = ville_res, cp_col = cp_res)

all.equal(enquete,
          select(enquete_post, 
                 names(enquete)))

enquete_post %>% 
  select(cp_res, starts_with("ville_res")) %>% 
  head(20)

## adding a country information

geocode_cities_cp(enquete, city_col = ville_res, cp_col = cp_res, country_col = pays_res) %>% 
  select(cp_res, starts_with("ville_res")) %>% 
  head(20)
```
