---
title: "ad-affectation_section"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ad-affectation_section}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message = FALSE}
library(evavelo)
library(dplyr)
library(banR)
library(geodist)
```
## Intro

Dans le chapitre 3.1.30:

Dans le cadre des extrapolations à conduire, il sera nécessaire de disposer d’une matrice des origines et destinations des itinérants. Celle-ci permettra de recomposer la répartition spatiale de la fréquentation itinérante sur l’itinéraire ou le réseau. La construction de cette matrice sera faite à partir des numéros des sections correspondant (id) aux communes de départ sur l’itinéraire [iti_depart_iti_valide] et d’arrivée sur l’itinéraire [iti_arrivee_iti_valide] déclarées par les répondants à la question 26. Pour réaliser cette matrice, il faut tout d’abord créer les champs [id_section_origine] et [id_section_dest]. Ensuite, l’affectation des « id » de section est faite en utilisant une fonction recherche entre la base de réponse et la table des communes de l’itinéraire [table_communes].

Il faut donc que je remplisse les champs **id_section_origine** et **id_section_dest** qui sont dans enquetes_post_traitement

```{r}
xlsx_path <- here::here("inst", "example-data", "02_simplified.xlsx")
enquete <- read_enquete(xlsx_path)

table_com <- openxlsx::read.xlsx(xlsx_path, sheet = "table_communes", startRow = 2)
```


```{r}
enquete %>% 
  select(id_quest, iti_depart_itineraire) %>% 
  count(iti_depart_itineraire)

```

## Detection de communes (table_communes)

Il va falloir faire de la reconnaissance de site.
J'utilise le package banR que j'ai légèrement modifié pour filtrer les communes.
Si jamais ma PR (https://github.com/joelgombin/banR/pull/32) n'est pas incorporée au package, il faudra que je redeveloppe la fonctionalté ici.

La fonction banR::geocode_tbl() est beaucoup plus rapide que la fonction banR::geocode(). Je peux en plus préciser un code Insee.
Je vais utiliser cette fonction pour vérifier la table des communes. 

La fonction `geocode_table_communes()` est créee pour geocoder les informations dans tables_communes


```{r}
## example of BanR use:
#banR::geocode("perros", limit = 1, type = "municipality")


table_communes <- openxlsx::read.xlsx(xlsx_path, sheet = "table_communes", startRow = 2) %>% 
  janitor::clean_names()
## Modify input to create an error
table_communes[1,"nom_commune"]<- "TREZENY"


## function that uses city names and COG codes to find position
evavelo::geocode_table_communes(table_communes) %>% 
  select(cog, nom_commune, latitude, longitude) %>% 
  head(20)



```

## Detection de commune (enquete)
*3.1.19*	Communes d’hébergement, de départ et d’arrivée, de résidence et code postal

Il est nécessaire d’homogénéiser la saisie des noms et de vérifier la concordance entre le nom de la commune et le code postal. Pour les communes d’hébergement [ville_heb], de départ sur l’itinéraire [iti_depart_itineraire] et d’arrivée sur l’itinéraire [iti_arrivee_itineraire], il est nécessaire de vérifier l’appartenance de ces communes à l’itinéraire ou au réseau évalué.


Finalement, j'ai plusieurs villes à étudier:

* ville_heb
* ville_res (associé à cp_res)
* iti_depart_itineraire
* iti_arrivee itineraire

### Ville_res (associé à cp_res)
```{r}

enquete <- read_enquete(xlsx_path) %>% 
  select(ville_heb, ville_res, iti_depart_itineraire, iti_arrivee_itineraire, cp_res, pays_res)


## Lets' work with ville_res first

enquete_post <- geocode_cities_cp(enquete, city_col = ville_res, cp_col = cp_res)

all.equal(enquete,
          select(enquete_post, 
                 names(enquete)))

enquete_post %>% 
  select(cp_res, starts_with("ville_res")) %>% 
  head(20)

## adding a country information

geocode_cities_cp(enquete, city_col = ville_res, cp_col = cp_res, country_col = pays_res) %>% 
  select(cp_res, starts_with("ville_res")) %>% 
  head(20)
```

### Autres villes

```{r}

enquete %>% 
  geocode_cities(ville_heb) %>% 
  head(20)


enquete_geocoded <- enquete %>% 
  geocode_cities(ville_heb) %>% 
  geocode_cities(iti_depart_itineraire) %>% 
  geocode_cities(iti_arrivee_itineraire)

enquete_geocoded %>% 
  head(20)

```

## Calcul de distance


Test de différents package de mesure de distances

Je commence par {geodist} qui est sans dépendances avec une implémentation en C++

### Mesure de distance point à point
```{r}
enquete_geocoded <- enquete_geocoded %>% 
  select(starts_with("iti")) %>% 
  tidyr::drop_na() 

enquete_geocoded%>% 
  mutate(
    dist_cheap = geodist_vec(
      x1 = iti_depart_itineraire_lon,
      y1 = iti_depart_itineraire_lat,
      x2 = iti_arrivee_itineraire_lon,
      y2 = iti_arrivee_itineraire_lat,
      paired = TRUE
  )) %>% 
  mutate(
    dist_haversine = geodist_vec(
      x1 = iti_depart_itineraire_lon,
      y1 = iti_depart_itineraire_lat,
      x2 = iti_arrivee_itineraire_lon,
      y2 = iti_arrivee_itineraire_lat,
      paired = TRUE,
      measure = "haversine"
  )) %>% 
  mutate(
    dist_geodesic = geodist_vec(
      x1 = iti_depart_itineraire_lon,
      y1 = iti_depart_itineraire_lat,
      x2 = iti_arrivee_itineraire_lon,
      y2 = iti_arrivee_itineraire_lat,
      paired = TRUE,
      measure = "geodesic"
  )) 
  
  
  

```

La methode "cheap" est la plus rapide mais n'est pas recommendé pour les distances de plus de 100 km. "Geodesic" est la plus fiable mais demande plus de calcul. "Haversine" semble être un bon compromis

### Mesure de distance en matrix


```{r}
## Distance matrix
geodist_matrix <- geodist_vec(
      x1 = enquete_geocoded$iti_depart_itineraire_lon,
      y1 = enquete_geocoded$iti_depart_itineraire_lat,
      x2 = c(0.9, 1, 1.1),
      y2 = c(46, 44, 48)
      )

geodist_matrix
## find closest value
apply(geodist_matrix, 1, which.min)

# x1 y1: position of sites
# x2 y2: reference position
# id : id of of references for output

get_closest_point <- function(x1, y1, x2, y2, id, ...){
  dist_matrix <- geodist::geodist_vec(x1,y1,x2,y2,...)
  idx_min <- apply(dist_matrix, 1, which.min)
  id[idx_min]
}

point <- data.frame(city = c("Perros", "Brest", "Lille", "Rennes")) %>% 
  geocode_cities(city)
ref <- data.frame(city = c("Nantes", "Paris")) %>% 
  geocode_cities(city)

get_closest_point(point$city_lon,
                  point$city_lat,
                  ref$city_lon,
                  ref$city_lat,
                  ref$city,
                  measure = "haversine")


```

